# Введение

Это рукводство показывает как использовать плагины пакетного буфера Slurm. Там, где это возможно, даётся разъяснение по работе дополнений, чтобы дать рекомендации по наилучшему их использованию.

Дополнение пакетного буфра Slurm вызывает скрипт на различных этапах жизненного цикла задачи: 

1) При создании задачи
2) Пока задача находится в режиме ожидания и оценивается её примерное время выполнения. Этот этап называется "Вступление"
3) Когда задача попадает в очередь выполнения, но ещё не запущена на выполнение. Эта стадия называется "предстартовая"
4) Когда задача выполнилась или была отменена, но Slurm ещё не освободил занятые ей ресурсы. Эта стадия называется "Выход"
5) Когда задача завершена и Slurm освободил занятые ей ресурсы. Эта стадия называется ""

Скрипт запускается на узле, где запущен демон slurmctld. Он поддерживает следующие дополнения: 

* datawrap
* lua

## Datawrap

Этот плагин обеспечивает обратные вызовы к API Cray's Datawrap. Datawrap реализует пакетные буферы, которые являюся общим высокоскоростным хранилищем ресурсов. Slurm обеспечивает поддержку выделения этих ресурсов, выделение файлов входных данных, бронирование вычислительных узлов для задачи, которая использует эти ресурсы и выделение файлов для выходных данных. Пакетные буферы также могут быть использованы как временное хранилище во время выполнения задачи, при этом не требуя выделения никаких файлов для записи и чтения. Другой типичный вариант использования - постоянное хранилище, не связанное с каким-либо конкретным заданием.

## Lua

Это расширение обеспечивает обратные вызывы для программного интерфейса, определяемого Lua-скриптом. Этот плагин был разработан для того, чтобы предоставить системным администраторам возможность выполнять любую задачу (не только промежуточную обработку файлов) на разных этапах жизненного цикла задания. Эти задачи могут включать в себя промежуточную обработку файлов, обслуживание узла или любую другую задачу, которую желательно выполнять во время одного или нескольких из пяти состояний задачи, перечисленных выше.

API-интерфейсы пакетного буфера будут вызываться только для задания, которое специально запрашивает их использование. В разделе "Команды отправки задания" объясняется, как задание может быть запрошено с использованием API пакетного буфера.

# Настройка (Для системных администраторов)
## Общая конфигурция

* Чтобы включить плагин burst buffer, установите тип Burst Buffer в slurm.conf. Если он не установлен, то плагин burst buffer загружен не будет. Может быть указан только один модуль пакетного буфера.
* В slurm.conf вы можете установить DEBUGFLAGS=Burst Buffer для подробного ведения журнала с помощью плагина burst buffer. Это приведет к очень подробному ведению журнала и не предназначено для длительного использования в производственной системе, но это может быть полезно для отладки.
* Пределы нагрузки для пакетных буферов могут быть сконфигурированы с помощью ассоциации или QOS таким же образом, как эти пределы могут быть сконфигурированы для узлов, процессоров или любых GRES. Чтобы заставить Slurm отслеживать ресурсы пакетного буфера, добавьте bb/datawarp (для плагина datawarp) или bb/lua (для плагина lua) в AccountingStorageTres в slurm.conf.
* Размер требований к пакетному буферу задания может использоваться в качестве фактора при установке приоритета задания, как описано в документе многофакторный приоритет. В разделе Ресурсы пакетного буфера объясняется, как определяются эти ресурсы.
* Конфигурации, специфичные для пакетного буфера, могут быть установлены в файле burst_buffer.conf. Параметры конфигурации включают в себя такие вещи, как то, какие пользователи могут использовать пакетные буферы, тайм-ауты, пути к пакетным буферным сценариям и т.д. Смотрите руководство burst_buffer.conf для получения дополнительной информации.
* Библиотека JSON-C должна быть установлена для создания плагинов Slurm burst_buffer/datawarp и burst_buffer/lua, которые должны анализировать данные в формате JSON. Подробности смотрите в информации об установке Slurm в формате JSON.

## Datawrap
`slurm.conf`:

    BurstBufferType=burst_buffer/datawarp

Datawrap плагин вызывает два скрипта:

* dw_wlan_cli - плагин Slurm burst_buffer/datawarp вызывает этот скрипт для выполнения функций пакетного буфера. Это должно было быть предоставлено компанией Cray. Местоположение этого скрипта определено Getsysstats в burst_buffer.conf.
Шаблон этого скрипта поставляется с Slurm: `src/plugins/burst_buffer/datawarp/dw_wlm_cli`
* dwstat - плагин Slurm burst_buffer/datawarp вызывает этот скрипт для получения информации о состоянии. Это должно было быть предоставлено компанией Cray. Местоположение этого скрипта определено Getsysstats в burst_buffer.conf. Шаблон этого скрипта поставляется с Slurm: `src/plugins/burst_buffer/datawarp/dwstat`

## LUA
`slurm.conf`:
    BurstBufferType=burst_buffer/lua
Плагин lua вызывает один скрипт, который должен иметь имя burst_buffer.lua. Этот скрипт должен существовать в том же каталоге, что и slurm.conf. Для существования необходимы следующие функции, хотя они могут ничего не делать, кроме как возвращать успех:

* slurm_bb_job_process
* slurm_bb_pools
* slurm_bb_job_teardown
* slurm_bb_setup
* slurm_bb_data_in
* slurm_bb_real_size
* slurm_bb_paths
* slurm_bb_pre_run
* slurm_bb_post_run
* slurm_bb_data_out
* slurm_bb_get_status

Шаблон burst_buffer.lua создаётся Slurm'ом по пути `etc/burst_buffer.lua.example`

В этом шаблоне задокументировано гораздо больше подробностей о функциях, таких как обязательные параметры, время вызова каждой функции, возвращаемые значения для каждой функции и несколько простых примеров.

# Имплементация Lua

Цель этого раздела - предоставить дополнительную информацию о плагине Lua, чтобы помочь системным администраторам, желающим внедрить Lua API. Наиболее важными моментами в этом разделе являются:
* Некоторые функции в burst_buffer.lua должны выполняться быстро и не могут быть остановлены; остальным функциям разрешено выполняться столько времени, сколько необходимо, и они могут быть остановлены.
* Одновременно разрешается запускать не более 512 копий burst_buffer.lua, чтобы избежать превышения системных ограничений.

## Как работает burst_buffer.lua

Lua-скрипты могут либо запускаться сами по себе в отдельном процессе с помощью системных вызовов `fork()` и `exec()`, либо они могут быть вызваны через C API Lua из существующего процесса. Одной из целей плагина lua было избежать вызова функции `fork()` из `slurmctld`, поскольку это может серьезно повлиять на производительность `slurmctld`. Плагин datawarp вызывает `fork()` и `exec()` из `slurmctld` для каждого вызова API пакетного буфера, и было показано, что это серьезно снижает производительность `slurmctld`. Следовательно, `slurmctld` вызывает burst_buffer.lua использует Lua's C API вместо использования `fork()`.

Некоторым функциям в burst_buffer.lua разрешено выполняться в течение длительного времени, но их, возможно, потребуется отключить, если задание отменено, если `slurmctld` перезапущен или если они выполняются дольше, чем заданный тайм-аут в burst_buffer.conf. Однако вызов Lua-скрипта через Lua C API не может быть остановлен внутри того же процесса; только завершение всего процесса, вызвавшего Lua-скрипт, может привести к завершению Lua-скрипта.

Чтобы устранить эту ситуацию, burst_buffer.lua вызывается двумя различными способами:
* Функции slurm_bb_job_process, slurm_bb_pools и slurm_bb_paths вызываются из slurmctld. Из-за приведенного выше объяснения скрипт, выполняющий одну из этих функций, не может быть уничтожен. Поскольку эти функции вызываются, когда slurmctld содержит некоторые мьютексы, их медленное выполнение будет крайне вредно для производительности slurmctld и быстродействия. Поскольку вызывать эти функции напрямую быстрее, чем вызывать fork() для создания нового процесса, это было сочтено приемлемым компромиссом. В результате эти функции не могут быть отключены.
* Остальные функции в burst_buffer.lua могут работать дольше без побочных эффектов. Их нужно уметь убивать. Эти функции вызываются из облегченного демона Slurm, называемого slurm script d. Всякий раз, когда требуется запустить одну из этих функций, slurmctld сообщает slurm script d запустить эту функцию; slurm script d затем вызывает fork() для создания нового процесса, а затем вызывает соответствующую функцию. Это позволяет избежать вызова fork() из slurmctld, в то же время предоставляя способ уничтожения запущенных копий burst_buffer.lua при необходимости. В результате эти функции могут быть отключены, и они будут отключены, если будут выполняться дольше соответствующего значения тайм-аута, настроенного в burst_buffer.configured.
Способ вызова каждой функции также задокументирован в файле burst_buffer.lua.example.

## Ограничения

Каждая копия скрипта, запускаемая с помощью slurm script d, запускается в новом процессе, и канал (который представляет собой файл) открывается для чтения ответов из скрипта. Чтобы избежать превышения лимитов на открытый процесс или открытый файл, нехватки памяти или превышения других системных ограничений, для каждого "этапа" разрешается одновременный запуск не более 128 копий сценария, где этапами являются поэтапный ввод, предварительный запуск, поэтапный вывод и демонтаж (см. раздел Состояния пакетного буфера для получения дополнительной информации о стадиях пакетного буфера). Это означает, что одновременно может быть запущено максимум 512 копий burst_buffer.lua. Без этого ограничения пропускная способность задания была ниже, и тестирование подтвердило, что лимит открытых файлов процесса мог быть превышен.

**ПРЕДУПРЕЖДЕНИЕ**: Не устанавливайте обработчик сигнала в burst_buffer.lua, потому что он вызывается непосредственно из slurmctld. Если slurmctld получит сигнал, он может попытаться запустить обработчик сигнала из burst_buffer.lua даже после завершения вызова burst_buffer.lua, что приведет к сбою.

# Ресурсы пакетного буфера

API пакетного буфера может определять “пулы” ресурсов пакетного буфера, из которых задание может запрашивать определенный объем пространства пула. Если в пуле недостаточно места для выполнения запроса задания, это задание будет оставаться незавершенным до тех пор, пока в пуле не будет достаточно места. Как только в бассейне будет достаточно места, Slurm может приступить к поэтапной подготовке к работе. Когда начинается этап ввода, Slurm вычитает запрошенное пространство задания из доступного пространства пула. Когда разборка завершается, Slurm добавляет запрошенное пространство задания обратно в доступное пространство пула. В разделе Команды отправки задания объясняется, как задание может запросить пространство из пула. Пространство пула - это скалярная величина.

## Datawrap

* Пулы определяются dw_wlm_cli и представляют собой байты. Этот скрипт выводит строку в формате JSON, определяющую пулы, в стандартный вывод.
* Если задание не запрашивает пул, то будет использоваться пул, определенный по умолчанию в burst_buffer.conf. Если задание не запрашивает пул и пул по умолчанию не определен, то задание будет отклонено.

## Lua

* Пулы в этом плагине необязательны и могут представлять все, что угодно.
* Пул по умолчанию в burst_buffer.conf в этом плагине не используется.
* Пулы определяются с помощью burst_buffer.lua в функции slurm_bb_pools. Если пулы нежелательны, то эта функция должна просто возвращать slurm.успех. Если требуются пулы, то эта функция должна возвращать два значения: (1) slurm.УСПЕХ, и (2) строка в формате JSON, определяющая пулы. Пример приведен в burst_buffer.lua.example. Текущими допустимыми полями в строке JSON являются:
* * id - строка, определяющая имя пула
* * quantity  - число, определяющее объем пространства в пуле
* * granularity (степень детализации) - число, определяющее наименьшее разрешение пространства, которое может быть выделено из этого пула. Если задание не запрашивает число, кратное степени детализации, то запрос задания будет округлен в большую сторону до ближайшего значения, кратного степени детализации. Например, если степень детализации равна 1000, то наименьший объем пространства, который может быть выделен из этого пула для одного задания, равен 1000. Если задание запрашивает менее 1000 единиц из этого пула, то запрос задания будет округлен до 1000.

# Команды отправки заданий
Обычный режим работы заключается в том, что пакетные задания определяют требования к буферу пакетов в рамках пакетного сценария. Прокомментированные строки пакетного скрипта, содержащие определенную директиву (в зависимости от того, какой плагин используется), сообщат Slurm, что он должен запустить этапы пакетного буферизации для этого задания. В этих строках также будут описаны требования к пакетному буферу для задания.

Команды salloc и srun могут указывать требования к буферу пакетов с помощью параметров --bb и --bbf. Это описано в разделе Параметры задания командной строки.

Все директивы пакетного буфера должны быть указаны в комментариях в верхней части пакетного скрипта. Они могут быть размещены до, после или перемежаться с любыми директивами #SBATCH. Все этапы пакетного буферизации происходят в определенные моменты жизненного цикла задания, как описано в разделе "Обзор"; они не происходят во время выполнения задания. Например, все создания и удаления постоянного буфера пакетов (используемого только плагином datawarp) происходят до выполнения вычислительной части задания. Аналогичным образом, вы не можете запускать поэтапный ввод в различных точках выполнения скрипта; поэтапное включение пакетного буфера выполняется перед началом задания, а поэтапное отключение - после завершения задания.

Для обоих плагинов задание может запрашивать определенный объем пространства (размер или емкость) из пула ресурсов пакетного буфера.

* Спецификация пула - это просто строка, которая соответствует названию пула. Например: pool=pool1
* Спецификация емкости - это число, указывающее объем пространства, требуемый для пула. Спецификация емкости может включать суффикс "N" (узлы), "K|KiB", "M|MiB", "G|GiB", "T|TiB", "P|PiB" (для степеней 1024) и "KB", "MB", "ГБ", "ТБ", "ПБ" (для степеней 1000). ПРИМЕЧАНИЕ: Обычно Slurm интерпретирует единицы измерения KB, MB, GB, TB, PB как степени 1024, но для спецификаций размера пакетных буферов Slurm поддерживает оба формата IEC/SI. Это связано с тем, что CRAY API поддерживает оба формата.

При отправке задания Slurm выполняет базовую проверку директивы, а также запускает функцию в сценарии пакетного буферизации. Эта функция может выполнять проверку директив, используемых в сценарии задания. Если Slurm определит, что параметры недопустимы, или если сценарий пакетного буферизации вернет ошибку, задание будет отклонено, и сообщение об ошибке будет возвращено непосредственно пользователю.

Обратите внимание, что нераспознанные параметры могут игнорироваться для поддержки обратной совместимости (т.е. отправка задания не завершится неудачей в случае параметра, распознанного некоторыми версиями Slurm, но не распознанного другими версиями). Если задание принято, но позже завершается сбоем (например, некоторые промежуточные файлы проблем), задание будет отложено, а в поле "Причина" будет указано сообщение об ошибке, предоставленное базовой инфраструктурой.

Пользователи также могут запросить уведомление по электронной почте о завершении этапа буферизации пакетов, используя параметр --mail-type=stage_out или --mail-type=all. В теме электронного письма будет указана следующая форма:

    SLURM Job_id=12 Name=my_app Staged Out, StageOut time 00:05:07

Следующие подразделы плагина содержат дополнительную информацию, специфичную для каждого плагина, и примеры сценариев заданий. Примеры командной строки приведены в разделе Параметры задания командной строки.

## Datawrap

Директива `#DW` (для "DataWarp") используется для директив пакетного буфера при использовании burst_buffer/data warpplugin. Пожалуйста, обратитесь к документации Cray для получения подробной информации о параметрах DataWarp. Для систем DataWarp директива #BB может использоваться для создания или удаления постоянного буферного хранилища пакетов.
ПРИМЕЧАНИЕ: Используется директива #BB, поскольку команда интерпретируется Slurm, а не программным обеспечением Cray Datawarp. Подробнее это обсуждается в разделе "Постоянный пакетный буфер".

Для пакетных буферов, специфичных для конкретного задания, требуется указать емкость пакетного буфера. Если в задании не указана пропускная способность, то задание будет отклонено. Задание также может указать пул, из которого ему требуются ресурсы; если в задании не указан пул, то будет использоваться пул, указанный DefaultPool в burst_buffer.conf (если он настроен).

Следующий сценарий задания запрашивает ресурсы пакетного буфера из пула по умолчанию и запрашивает файлы для поэтапного ввода и поэтапного вывода:

    #!/bin/bash
    #DW jobdw type=scratch capacity=1GB access_mode=striped,private pfs=/scratch
    #DW stage_in type=file source=/tmp/a destination=/ss/file1
    #DW stage_out type=file destination=/tmp/b source=/ss/file1
    srun application.sh

---
## Lua

Директива по умолчанию для этого плагина - #BB_LUA. Директива, используемая этим плагином, может быть изменена путем установки параметра Directive в burst_buffer.conf. Поскольку директива всегда должна начинаться со знака # (который запускает комментарий в сценарии оболочки), этот параметр должен указывать только строку, следующую за знаком #. Например, если файл burst_buffer.conf содержит следующее:

    Directive=BB_EXAMPLE

тогда директива пакетного буфера будет #BB_EXAMPLE.

Если параметр Directive не указан в burst_buffer.conf, то будет использоваться директива по умолчанию для этого плагина (#BB_LUA).

Поскольку этот плагин был разработан таким образом, чтобы быть универсальным и гибким, для этого плагина требуется только указать директиву. Если указана директива, Slurm запустит все этапы пакетного буферизации для задания.

Пример минимальной информации, необходимой для выполнения задания на всех этапах пакетного буферизации:

    #!/bin/bash
    #BB_LUA
    srun application.sh

Поскольку пулы пакетных буферов являются необязательными для этого плагина (см. раздел Ресурсы пакетного буфера), задание не требуется для указания пула или емкости. Если пулы предоставляются API пакетного буфера, то задание может запросить пул и емкость:

    #!/bin/bash
    #BB_LUA pool=pool1 capacity=1K
    srun application.sh

Задание может выбирать, указывать пул или нет. Если в задании не указан пул, то заданию по-прежнему разрешено выполняться, и этапы пакетного буферизации по-прежнему будут выполняться для этого задания (при условии, что была задана директива пакетного буферизации). Если в задании указан пул, но этот пул не найден, то задание отклоняется.

Системный администратор может проверить параметры пакетного буфера в функции slurm_bb_job_process в burst_buffer.lua. Это может включать требование задания указать пул или проверку любых дополнительных параметров, которые системный администратор решит реализовать.  